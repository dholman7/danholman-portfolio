metadata:
  name: "REST API Testing Rules"
  version: "1.0.0"
  description: "Comprehensive rules for testing REST APIs with proper validation and error handling"
  languages: ["python", "typescript", "javascript"]
  frameworks: ["pytest", "jest", "requests", "supertest"]
  categories: ["api", "integration", "contract"]
  author: "Dan Holman"
  license: "MIT"

rules:
  - name: "API Test Structure and Organization"
    description: "Organize API tests with proper structure and naming conventions"
    content: |
      # Organize API tests by endpoint or feature
      # Use descriptive test names that explain the API behavior
      # Group related tests in classes or describe blocks
      # Test both success and error scenarios
      
      # Python with pytest
      class TestUserAPI:
          """Test suite for User API endpoints."""
          
          def test_get_user_returns_200_with_valid_id(self):
              """Test GET /users/{id} returns 200 with user data."""
              pass
          
          def test_get_user_returns_404_with_invalid_id(self):
              """Test GET /users/{id} returns 404 for non-existent user."""
              pass
          
          def test_create_user_returns_201_with_valid_data(self):
              """Test POST /users returns 201 with created user."""
              pass
      
      # TypeScript with Jest
      describe('User API', () => {
        describe('GET /users/:id', () => {
          it('should return 200 with user data for valid ID', async () => {
            // Test implementation
          });
          
          it('should return 404 for non-existent user ID', async () => {
            // Test implementation
          });
        });
        
        describe('POST /users', () => {
          it('should return 201 with created user for valid data', async () => {
            // Test implementation
          });
        });
      });
    tags: ["structure", "organization", "naming", "grouping"]
    priority: 1

  - name: "HTTP Methods and Status Codes"
    description: "Test all HTTP methods and appropriate status codes"
    content: |
      # Test all relevant HTTP methods (GET, POST, PUT, PATCH, DELETE)
      # Verify correct status codes for different scenarios
      # Test both success and error status codes
      # Use appropriate HTTP methods for the operation
      
      def test_user_endpoints_status_codes():
          """Test all user endpoints return correct status codes."""
          base_url = "https://api.example.com"
          
          # GET - Retrieve resource
          response = requests.get(f"{base_url}/users/1")
          assert response.status_code == 200
          
          # POST - Create resource
          user_data = {"name": "Test User", "email": "test@example.com"}
          response = requests.post(f"{base_url}/users", json=user_data)
          assert response.status_code == 201
          
          # PUT - Update entire resource
          updated_data = {"name": "Updated User", "email": "updated@example.com"}
          response = requests.put(f"{base_url}/users/1", json=updated_data)
          assert response.status_code == 200
          
          # PATCH - Partial update
          patch_data = {"name": "Patched User"}
          response = requests.patch(f"{base_url}/users/1", json=patch_data)
          assert response.status_code == 200
          
          # DELETE - Remove resource
          response = requests.delete(f"{base_url}/users/1")
          assert response.status_code == 204
      
      def test_error_status_codes():
          """Test appropriate error status codes."""
          base_url = "https://api.example.com"
          
          # 400 - Bad Request
          response = requests.post(f"{base_url}/users", json={"invalid": "data"})
          assert response.status_code == 400
          
          # 401 - Unauthorized
          response = requests.get(f"{base_url}/users/1", headers={"Authorization": "invalid"})
          assert response.status_code == 401
          
          # 403 - Forbidden
          response = requests.delete(f"{base_url}/users/1", headers={"Authorization": "Bearer user_token"})
          assert response.status_code == 403
          
          # 404 - Not Found
          response = requests.get(f"{base_url}/users/999")
          assert response.status_code == 404
          
          # 422 - Unprocessable Entity
          response = requests.post(f"{base_url}/users", json={"name": "", "email": "invalid"})
          assert response.status_code == 422
    tags: ["http-methods", "status-codes", "errors", "validation"]
    priority: 1

  - name: "Request and Response Validation"
    description: "Validate request payloads and response structures"
    content: |
      # Validate request payload structure and data types
      # Validate response structure, data types, and required fields
      # Test with various data combinations
      # Validate headers and content types
      
      def test_create_user_request_validation():
          """Test user creation with various request payloads."""
          base_url = "https://api.example.com"
          
          # Valid request
          valid_data = {
              "name": "John Doe",
              "email": "john@example.com",
              "age": 30,
              "role": "user"
          }
          response = requests.post(f"{base_url}/users", json=valid_data)
          assert response.status_code == 201
          
          # Validate response structure
          user = response.json()
          assert "id" in user
          assert "name" in user
          assert "email" in user
          assert "created_at" in user
          assert user["name"] == valid_data["name"]
          assert user["email"] == valid_data["email"]
          
          # Test missing required fields
          incomplete_data = {"name": "John Doe"}
          response = requests.post(f"{base_url}/users", json=incomplete_data)
          assert response.status_code == 400
          error = response.json()
          assert "email" in error["errors"]
      
      def test_response_content_type_and_headers():
          """Test response content type and headers."""
          response = requests.get("https://api.example.com/users/1")
          
          # Validate content type
          assert response.headers["content-type"] == "application/json"
          
          # Validate custom headers
          assert "X-Request-ID" in response.headers
          assert "X-Rate-Limit-Remaining" in response.headers
          
          # Validate response body is valid JSON
          data = response.json()
          assert isinstance(data, dict)
      
      def test_query_parameters():
          """Test API query parameters."""
          base_url = "https://api.example.com/users"
          
          # Test pagination
          response = requests.get(f"{base_url}?page=1&limit=10")
          assert response.status_code == 200
          data = response.json()
          assert "users" in data
          assert "pagination" in data
          assert data["pagination"]["page"] == 1
          assert data["pagination"]["limit"] == 10
          
          # Test filtering
          response = requests.get(f"{base_url}?role=admin&active=true")
          assert response.status_code == 200
          users = response.json()["users"]
          assert all(user["role"] == "admin" for user in users)
    tags: ["validation", "payloads", "responses", "headers", "query-params"]
    priority: 1

  - name: "Authentication and Authorization"
    description: "Test API authentication and authorization mechanisms"
    content: |
      # Test various authentication methods (API keys, JWT, OAuth)
      # Test authorization levels and permissions
      # Test token expiration and refresh
      # Test unauthorized access scenarios
      
      def test_api_key_authentication():
          """Test API key authentication."""
          base_url = "https://api.example.com"
          
          # Valid API key
          headers = {"X-API-Key": "valid-api-key"}
          response = requests.get(f"{base_url}/users", headers=headers)
          assert response.status_code == 200
          
          # Invalid API key
          headers = {"X-API-Key": "invalid-key"}
          response = requests.get(f"{base_url}/users", headers=headers)
          assert response.status_code == 401
          
          # Missing API key
          response = requests.get(f"{base_url}/users")
          assert response.status_code == 401
      
      def test_jwt_authentication():
          """Test JWT token authentication."""
          base_url = "https://api.example.com"
          
          # Get token
          login_data = {"username": "testuser", "password": "testpass"}
          login_response = requests.post(f"{base_url}/auth/login", json=login_data)
          assert login_response.status_code == 200
          
          token = login_response.json()["access_token"]
          headers = {"Authorization": f"Bearer {token}"}
          
          # Use token for authenticated request
          response = requests.get(f"{base_url}/users/profile", headers=headers)
          assert response.status_code == 200
          
          # Test expired token
          expired_token = "expired.jwt.token"
          headers = {"Authorization": f"Bearer {expired_token}"}
          response = requests.get(f"{base_url}/users/profile", headers=headers)
          assert response.status_code == 401
      
      def test_authorization_levels():
          """Test different authorization levels."""
          base_url = "https://api.example.com"
          
          # Admin user can access all endpoints
          admin_headers = {"Authorization": "Bearer admin-token"}
          response = requests.get(f"{base_url}/admin/users", headers=admin_headers)
          assert response.status_code == 200
          
          # Regular user cannot access admin endpoints
          user_headers = {"Authorization": "Bearer user-token"}
          response = requests.get(f"{base_url}/admin/users", headers=user_headers)
          assert response.status_code == 403
          
          # User can only access their own data
          response = requests.get(f"{base_url}/users/1", headers=user_headers)
          assert response.status_code == 200
          
          response = requests.get(f"{base_url}/users/2", headers=user_headers)
          assert response.status_code == 403
    tags: ["authentication", "authorization", "jwt", "api-keys", "permissions"]
    priority: 1

  - name: "Error Handling and Edge Cases"
    description: "Test comprehensive error handling and edge cases"
    content: |
      # Test various error conditions and edge cases
      # Test malformed requests and invalid data
      # Test rate limiting and timeout scenarios
      # Test server errors and maintenance scenarios
      
      def test_validation_errors():
          """Test input validation error handling."""
          base_url = "https://api.example.com"
          
          # Invalid email format
          invalid_data = {"name": "Test User", "email": "invalid-email"}
          response = requests.post(f"{base_url}/users", json=invalid_data)
          assert response.status_code == 422
          error = response.json()
          assert "email" in error["errors"]
          assert "invalid format" in error["errors"]["email"][0].lower()
          
          # Missing required fields
          incomplete_data = {"name": "Test User"}
          response = requests.post(f"{base_url}/users", json=incomplete_data)
          assert response.status_code == 400
          error = response.json()
          assert "email" in error["errors"]
      
      def test_edge_cases():
          """Test edge cases and boundary conditions."""
          base_url = "https://api.example.com"
          
          # Empty request body
          response = requests.post(f"{base_url}/users", json={})
          assert response.status_code == 400
          
          # Very large payload
          large_data = {"name": "x" * 10000, "email": "test@example.com"}
          response = requests.post(f"{base_url}/users", json=large_data)
          assert response.status_code in [400, 413]  # Bad Request or Payload Too Large
          
          # Special characters in data
          special_data = {"name": "Test User <script>alert('xss')</script>", "email": "test@example.com"}
          response = requests.post(f"{base_url}/users", json=special_data)
          assert response.status_code == 201  # Should be sanitized, not rejected
          
          # Unicode characters
          unicode_data = {"name": "测试用户", "email": "test@example.com"}
          response = requests.post(f"{base_url}/users", json=unicode_data)
          assert response.status_code == 201
      
      def test_rate_limiting():
          """Test rate limiting behavior."""
          base_url = "https://api.example.com"
          headers = {"X-API-Key": "test-key"}
          
          # Make requests up to rate limit
          for i in range(100):  # Assuming rate limit is 100 requests per minute
              response = requests.get(f"{base_url}/users", headers=headers)
              if response.status_code == 429:  # Too Many Requests
                  break
              assert response.status_code == 200
          
          # Next request should be rate limited
          response = requests.get(f"{base_url}/users", headers=headers)
          assert response.status_code == 429
          assert "X-Rate-Limit-Remaining" in response.headers
          assert "Retry-After" in response.headers
      
      def test_server_errors():
          """Test server error handling."""
          base_url = "https://api.example.com"
          
          # Test 500 Internal Server Error
          response = requests.get(f"{base_url}/error-endpoint")
          assert response.status_code == 500
          error = response.json()
          assert "error" in error
          assert "Internal Server Error" in error["error"]
          
          # Test 503 Service Unavailable
          response = requests.get(f"{base_url}/maintenance")
          assert response.status_code == 503
    tags: ["error-handling", "edge-cases", "validation", "rate-limiting", "server-errors"]
    priority: 2

  - name: "Performance and Load Testing"
    description: "Test API performance characteristics and load handling"
    content: |
      # Test response times for different endpoints
      # Test concurrent request handling
      # Test with various payload sizes
      # Monitor resource usage and performance metrics
      
      def test_response_times():
          """Test API response times are within acceptable limits."""
          base_url = "https://api.example.com"
          
          # Test simple GET request
          start_time = time.time()
          response = requests.get(f"{base_url}/users/1")
          end_time = time.time()
          
          assert response.status_code == 200
          assert (end_time - start_time) < 1.0  # Should respond within 1 second
          
          # Test complex query
          start_time = time.time()
          response = requests.get(f"{base_url}/users?page=1&limit=100&sort=name")
          end_time = time.time()
          
          assert response.status_code == 200
          assert (end_time - start_time) < 2.0  # Complex query within 2 seconds
      
      def test_concurrent_requests():
          """Test API handles concurrent requests properly."""
          import concurrent.futures
          import threading
          
          base_url = "https://api.example.com"
          results = []
          
          def make_request(user_id):
              response = requests.get(f"{base_url}/users/{user_id}")
              return response.status_code
          
          # Make 50 concurrent requests
          with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
              futures = [executor.submit(make_request, i) for i in range(1, 51)]
              results = [future.result() for future in concurrent.futures.as_completed(futures)]
          
          # All requests should succeed
          assert all(status == 200 for status in results)
          assert len(results) == 50
      
      def test_payload_size_impact():
          """Test how payload size affects performance."""
          base_url = "https://api.example.com"
          
          # Small payload
          small_data = {"name": "Test", "email": "test@example.com"}
          start_time = time.time()
          response = requests.post(f"{base_url}/users", json=small_data)
          small_time = time.time() - start_time
          assert response.status_code == 201
          
          # Large payload
          large_data = {
              "name": "Test User",
              "email": "test@example.com",
              "description": "x" * 10000,
              "metadata": {"key" + str(i): "value" + str(i) for i in range(1000)}
          }
          start_time = time.time()
          response = requests.post(f"{base_url}/users", json=large_data)
          large_time = time.time() - start_time
          assert response.status_code == 201
          
          # Large payload should take longer but still be reasonable
          assert large_time < 5.0  # Should complete within 5 seconds
      
      def test_database_performance():
          """Test database query performance."""
          base_url = "https://api.example.com"
          
          # Test simple query
          start_time = time.time()
          response = requests.get(f"{base_url}/users?limit=10")
          simple_time = time.time() - start_time
          assert response.status_code == 200
          
          # Test complex query with joins
          start_time = time.time()
          response = requests.get(f"{base_url}/users?include=orders,profile&sort=created_at&order=desc")
          complex_time = time.time() - start_time
          assert response.status_code == 200
          
          # Complex query should take longer but still be reasonable
          assert complex_time < simple_time * 3  # Not more than 3x longer
    tags: ["performance", "load-testing", "concurrency", "response-times"]
    priority: 3
